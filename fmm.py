# -*- coding: utf-8 -*-

# description   : 前向分词
#
# 1. 前向最大匹配（forward-max matching）
# 前向最大匹配的前向意思是说，从前往后匹配。最大意思是说，我们匹配的词的长度越大越好，也就是这句话中分出来的词的数量越少越好。
# 这里，我们假设这个最大长度max_len = 5:
#
# 第一轮搜索：
# ①"南京市长江 大桥" 词典中没有南京市长江这个词，匹配失败
# ②"南京市长 江大桥" 词典中没有南京市长这个词，匹配失败
# ③"南京市长江大桥" 词典中没有南京市这个词，匹配失败
# ④"南京市长江大桥" 词典中有南京这个词，匹配成功，去除
# 句子变为：“市长江大桥”
#
# 第二轮搜索：
# ①"市长江大桥" 词典中没有市长江大桥这个词，匹配失败
# ②"市长江大桥" 词典中没有市长江大这个词，匹配失败
# ③"市长江大桥" 词典中没有市长江这个词，匹配失败
# ④"市长江大桥" 词典中有市长这个词，匹配成功，去除
# 句子变为：“江大桥”
#
# 第三轮搜索（句子长度已不足5，将max_len改为3）：
# ①"江大桥" 词典中没有江大桥这个词，匹配失败
# ②"江大桥"" 词典中没有江大这个词，匹配失败
# ③"江大桥" 词典中有江这个词，匹配成功，去除
# 句子变为：“大桥”
#
# 第四轮搜索：
# ①"大桥" 词典中有大桥这个词，匹配成功，去除
# 句子变为：""，说明已经处理完毕
#
# 最终结果：“南京 / 市长 / 江 / 大桥”
#
# 这个结果虽然勉强可以接受，可以认为它说的意思是，南京的市长名字叫江大桥，但是明显跟我们想要表达的或者想要理解的意思不一样，这就有了分词的歧义问题。
# 如果我们的词典里有南京市这个词，那么结果就是"南京市/长江/大桥"。


dictionaries = ["南京", "市长", "大桥", "长江", "江", "市"]


# 前向最大匹配
def forward_max_matching(text, max_len=5):
    result = []
    text_ = text
    index = max_len

    while len(text_) > 0:

        if index == 0:
            print("分词失败，词典中没有这个词")
            return []

        if text_[:index] in dictionaries:
            result.append(text_[:index])
            text_ = text_[index:]
            index = 5
        else:
            index = index - 1

    return "".join(word + "/" for word in result)

if __name__ == '__main__':
    content = "南京市长江大桥"
    forward_result = forward_max_matching(content)
    print("forward_result:", forward_result)
